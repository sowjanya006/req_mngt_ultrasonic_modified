/*
 * Testdriver source generated by TESSY
 *
 * (c) Razorcat Development GmbH
 *
 * DO NOT EDIT THIS FILE !
 *
 *
 * File          : Slave Source (ts_vehdist_s.c)
 * Testpath      : C:/Users/Sowjanya/Projects/TESSY/REQ_MN~3/tessy\work\00000401\00000402\00000403\0000046F
 * Modulename    : New Module
 * Testobjectname: vehdist
 * Date          : 21.07.2020
 * Time          : 09:51:02
 * Tessy Version : 4.2.8
 *
 */

#define __TS_THIS_IS_THE_SLAVE__
#include "ts_vehdist_s.h"

#include "tstcomm.h"
extern void exit(int);


#include "ts_env.h"

/*
 * Prolog/Epilog functions
 */
#ifdef __cplusplus
extern "C" {
#endif
void ts_tobj_prolog (void);
void ts_tobj_epilog (void);
void ts_tc_prolog (void);
void ts_tc_epilog (void);
#ifdef __cplusplus
}
#endif

#ifndef TESSY_NULL
   #define TESSY_NULL ((void *) 0)
#endif

#ifndef NULL
   #define NULL TESSY_NULL
#endif

/* Current mode */
#define TS_MODE_END         0
#define TS_MODE_TESTOBJECT  1
#define TS_MODE_TESTCASE    2
#define TS_MODE_TESTSTEP    3
TESSY_uint32 TS_CURRENT_TESTCASE;
TESSY_uint32 TS_CURRENT_TESTSTEP;
TESSY_uint32 TS_CommTransferLimit;
TESSY_uint8  TS_FAULT_INJECTION;
static char    ts_mode;

/* repeatcount*/
TESSY_uint32        TS_REPEAT_COUNT;
static TESSY_uint32 TS_REPEAT_COUNT_2;
static char   TS_EXECUTE_TESTSTEP_PROLOG;
static char   TS_EXECUTE_TESTSTEP_EPILOG;

/* slave error code */
static unsigned char ts_errno;

/*
 * Slave Function Definitions
 */
char TESSY_use_value(void) {
   return tstcomm_get_char();
}


/*
 * Receive/send data for dynamic objects 
 */

/*
 * Receive Testdata from master
 */
extern void TESSY_receive_TD01(void);
static void TESSY_receive_TD(void)
{
   TESSY_receive_TD01();
}


/*
 * Send Actual Data to master
 */
extern void TESSY_send_TD01(void);
extern void TESSY_send_return(void);
static void TESSY_send_AD(void)
{
   TESSY_send_TD01();
   TESSY_send_return();
}


/*
 * Task Control
 */
void tessy_init_task(void)
{
   TS_CommTransferLimit = 0;
   TS_CURRENT_TESTCASE = TS_CURRENT_TESTSTEP = 0;
   TS_FAULT_INJECTION = 0;
   TS_REPEAT_COUNT = 1;
   TS_REPEAT_COUNT_2 = 0;
   ts_mode = TS_MODE_TESTOBJECT;
   tstcomm_disable_send = 1;

   if (TS_SUCCESS != tstcomm_open()) {
     tstcomm_error_exit(TSTCOMM_ERROR_INIT_COMM);
   }

}

void tessy_start_task(void)
{
   switch (ts_mode) {
      case TS_MODE_TESTOBJECT:
         if (TS_REPEAT_COUNT_2 == 0) {
#if defined TS_SUPPORT_SCRIPT
            tstcomm_user_script(TSTCOMM_PROLOG, TS_CURRENT_TESTCASE, TS_CURRENT_TESTSTEP);
#endif /* TS_SUPPORT_SCRIPT */
            ts_tobj_prolog();
            ts_mode++;

         }
      /**/case TS_MODE_TESTCASE:
         if (TS_REPEAT_COUNT_2 == 0) {
            if (0 == (TS_CURRENT_TESTCASE = tstcomm_get_ulong())) {
               ts_mode--;
               break;
            }
            TS_FAULT_INJECTION = tstcomm_get_uchar();
#if defined TS_SUPPORT_SCRIPT
            tstcomm_user_script(TSTCOMM_PROLOG, TS_CURRENT_TESTCASE, TS_CURRENT_TESTSTEP);
#endif /* TS_SUPPORT_SCRIPT */
            ts_tc_prolog();
            ts_mode++;

         }
      /**/case TS_MODE_TESTSTEP:
         ts_errno = 0;
         if (TS_REPEAT_COUNT_2 == 0) {
            if (0 == (TS_CURRENT_TESTSTEP = tstcomm_get_ulong())) {
               ts_mode--;
               break;
            }
            TS_REPEAT_COUNT_2 = tstcomm_get_ulong();
#if defined TS_SUPPORT_SCRIPT
            TS_EXECUTE_TESTSTEP_PROLOG = tstcomm_get_execute_user_script(TSTCOMM_PROLOG, TS_CURRENT_TESTCASE, TS_CURRENT_TESTSTEP);
            TS_EXECUTE_TESTSTEP_EPILOG = tstcomm_get_execute_user_script(TSTCOMM_EPILOG, TS_CURRENT_TESTCASE, TS_CURRENT_TESTSTEP);
#endif /* TS_SUPPORT_SCRIPT */
            TESSY_receive_TD();
         }
         if (TS_EXECUTE_TESTSTEP_PROLOG) {
#if defined TS_SUPPORT_SCRIPT
            tstcomm_execute_user_script(TSTCOMM_PROLOG, TS_CURRENT_TESTCASE, TS_CURRENT_TESTSTEP);
#endif /* TS_SUPPORT_SCRIPT */
         }
         ts_tc_prolog();
         if (TS_REPEAT_COUNT <= 0) TS_REPEAT_COUNT = 1;
   }
}

extern void TESSY_TestobjectCall(void);
void tessy_execute_task(void)
{
   if (ts_mode == TS_MODE_TESTSTEP) {
      while (TS_REPEAT_COUNT) {
         TESSY_TestobjectCall();
         TS_REPEAT_COUNT--;
      }
   }
}

void tessy_end_task(void)
{
   switch (ts_mode) {
      case TS_MODE_TESTOBJECT:
#if defined TS_SUPPORT_SCRIPT
         tstcomm_user_script(TSTCOMM_EPILOG, TS_CURRENT_TESTCASE, TS_CURRENT_TESTSTEP);
#endif /* TS_SUPPORT_SCRIPT */
         ts_tobj_epilog();
         tstcomm_close();
         exit(0);

      /**/case TS_MODE_TESTCASE:
#if defined TS_SUPPORT_SCRIPT
         tstcomm_user_script(TSTCOMM_EPILOG, TS_CURRENT_TESTCASE, TS_CURRENT_TESTSTEP);
#endif /* TS_SUPPORT_SCRIPT */
         ts_tc_epilog();
         break;

      case TS_MODE_TESTSTEP:
         if (TS_EXECUTE_TESTSTEP_EPILOG) {
#if defined TS_SUPPORT_SCRIPT
            tstcomm_execute_user_script(TSTCOMM_EPILOG, TS_CURRENT_TESTCASE, TS_CURRENT_TESTSTEP);
#endif /* TS_SUPPORT_SCRIPT */
         }
         ts_tc_epilog();
         TS_REPEAT_COUNT_2--;
         if (!TS_REPEAT_COUNT_2) {
            /* send 0 to mark test end */
            tstcomm_put_uchar(0);
            /* send ts_errno */
            tstcomm_put_uchar(ts_errno);
            TESSY_send_AD();
         }
   }
}

/* declare Windows(TM) function to avoid crash dialogue
   (including <windows.h> may collide with customer code) */
#ifdef __cplusplus
extern "C"
#else
extern
#endif
unsigned int __attribute__((__stdcall__)) SetErrorMode(unsigned int);

/*
 * main
 */
#if !defined TS_OTHER_MAIN
int main(void)
{
   /* disable Windows(TM) crash dialogue */
   unsigned long oldMode = SetErrorMode(0);
   SetErrorMode(oldMode | 0x0002);

   tessy_init_task();

   while (1) {
      tstcomm_disable_send = 1;
      tessy_start_task();
      tstcomm_disable_send = 0;
      tessy_execute_task();
      tessy_end_task();
   }
   return 0;
}
#endif
